# JVM

* JVM（Java Virtual Machine）java虚拟机
<img src='./images/2.png'>

* 大概流程：
    1. `类加载器`加载`Class`字节码文件到JVM中
    2. 类信息、静态变量、常量放到`方法区`
    3. 类产生的实例对象、数组放到`堆`
    4. `堆`中的对象调用方法时，会用到`程序计数器`、`虚拟机栈`、`本地方法栈`
        1. 某线程执行，会开辟一个该线程的`虚拟机栈`
        2. 调用方法m1，会在`虚拟机栈`中开辟一个栈帧，包含局部变量表、操作数、动态链接、方法返回等信息，将栈帧压入栈
        3. 方法m1调用方法m2，m2对应的栈帧也会压入栈中
    5. 方法执行时需要用到`执行引擎`
        1. 代码由`执行引擎`中的`解释器`执行
        2. 方法中的热点代码需要用`即时编译器`编译，相当于一个优化的过程
        3. `执行引擎`中有`GC`，对堆中的不再被引用的对象进行垃圾回收♻️
        4. 某些功能需要调用`本地方法接口`
* 各内存区域：
    * `方法区`：存放 类信息、静态变量、常量、类加载器，所有线程共享，虚拟机启动时创建，逻辑上时堆的一部分
        * 字节码文件包含：类信息、常量池`Constant pool`、类的方法定义、虚拟机指令（`javap -v A.class`可查看）
        * 常量池就是一张表，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型等
    * `堆`：存放 对象引用
    * `程序计数器`：某线程内，记录当前虚拟机真正执行的线程指令地址
    * `虚拟机栈`：每个线程，都会在该区域开辟一个属于自己的线程栈，线程中的每个方法对应一个栈帧，方法中包含局部变量表、操作数、动态链接、方法返回等
    * `本地方法栈`：某线程内，某些方法，并非使用java编写，而是
C/C++编写，`本地方法栈`是这些方法运行区域，如`Object.clone()`方法
    
* 问题：
     * `方法区`内存溢出`OutOfMemoryError: PermGenspace/Matespace`：
        * 类加载器，加载了很多类
            * `1.6`以前是`OutOfMemoryError: PermGen space(永久带)`
            * `1.8`以后`OutOfMemoryError: Matespace（元空间）`
    * `堆`内存溢出`'OutOfMemoryError: Java heap space'`
        * 产生了太多对象，一直引用着，没有被`GC`回收
     * `虚拟机栈`内存溢出 `StackOverflowError`：
        * 栈帧过多，方法循环递归调用
        * 栈帧过大，局部变量占用内存过大，如两个对象相互引用，并转为json字符串，会造成一个对象的局部变量循环无限大
